# Métricas Ágeis
<h2>Obtenha melhores resultados em sua equipe</h2>

“Metrificar é o primeiro passo para o controle e eventualmente para melhoria. Se você não consegue medir algo, você não consegue entendê-lo. Se você não consegue capturá-lo, você não consegue controlá-lo. Se você não consegue controlá-lo, você não consegue melhorá-lo”. 
<b>HARRIGTON, H. James.</b>

<h3>Comparação de construção de software com elaboração de um artefato científico</h3>

* Observar o fenômeno = Problema de negócio.
* Formular uma hipótese para explicar o fenômeno = Funcionalidades que resolverão o problema de negócio.
* Usar a hipótese para fazer uma predição = Suposições de utilidade do produto no mundo real
* Testar a predição através de experimentos ou novas observações, e modificar a hipótese com base nos resultados do teste = Pegar o feedback e dar uma nova diretiva

<h3>Planejamento, Execução, Verificação = Ação</h3>

* Uma das grandes dificuldades que as equipes têm ao construírem uma solução é a de compreenderem como ela se conecta com os objetivos de negócio de uma organização. Como reflexo de tal desalinhamento, temos situações nas quais são criadas soluções em que grande parte das funcionalidades raramente ou nunca utilizadas.

* Se você trabalha em um ambiente que não conta com um processo para se construir software, é bem provável que você lide com desafios na qualidade do produto final, na organização e otimização dos recursos, e no planejamento do que será entregue. É melhor se ter um processo com suas limitações e que pode ser evoluído do que trabalhar em um local caótico.

* Enquanto no modelo tradicional existe uma separação entre as etapas necessárias para a construção de um software, no modelo ágil tal separação não existe, dado que há uma multidisciplinaridade das pessoas envolvidas na criação da solução.

* Uma das grandes diferenças entre as abordagens de desenvolvimento de software ágil e tradicional diz respeito a qualidade e testes. Ao passo que, no modelo tradicional, a fase de teste vem depois da fase de construção, na abordagem ágil, os testes são feitos concomitantemente com o desenvolvimento.

* O modelo tradicional não serve para nenhum caso? Depende. Se você está lidando com situações nas quais há uma clareza nas funcionalidades que precisarão ser construídas e que não haverá qualquer tipo de mudança no que se espera com o produto final, utilizar um modelo tradicional pode ser mais eficiente. Agora, dada a natureza da incerteza que envolve o desenvolvimento de software e sabendo que a única certeza é que existirão mudanças, é aconselhável se pensar em seguir o processo ágil.

<h3>Kanban</h3>

Em 2010 David Anderson criou o que ele chamou de “sistema Kanban para desenvolvimento de software”, que combina o pensamento lean e a teoria das restrições.

* <b>Comece com o que você já faz hoje:</b> Crie formas de visibilidade e busque evoluir o processo.
* <b>Busque mudanças incrementais:</b> Melhore sempre sem ser radical.
* <b>Respeite o processo atual, seus papéis, responsabilidades e cargos:</b> Faça melhorias evolutivas e não seja disruptivo.
* <b>Visualize o fluxo de trabalho:</b> Divida o trabalho em partes, escreva cada demanda em um cartão e tenha visão de todo o trabalho em andamento.
* <b>Limite o trabalho em progresso:</b> Atribua limites explícitos para a quantidade de itens que podem estar em andamento em cada etapa do fluxo de trabalho.
* <b>Torne as políticas explícitas:</b> Defina, divulgue e socialize o processo, assim todos terão uma clareza de como funciona e de como o trabalho é realmente feito.
* <b>Desenvolva loops de feedback:</b> Reduza o tempo do ciclo de feedback, pois quanto mais tardia a entrega, mais demorada será a geração de valor daquilo que foi trabalhado.
* <b>Melhore de forma colaborativa:</b> Exerça a filosofia de melhoria contínua baseada no kaizen.

<h3>Benefícios Kanban</h3>

* Os gargalos do processo ficarão visíveis em tempo real, o que levará as pessoas a colaborarem para otimizar toda a cadeia de valor em vez de olhar apenas para a sua parte.
* Provê um caminho mais ameno quando a organização está em um processo de transição de uma abordagem tradicional para uma abordagem de desenvolvimento de software ágil.
* Fornece uma maneira de criar software de forma ágil sem necessariamente lidar com iterações de tempo fixo, como por exemplo, as sprints do Scrum.
* Útil para situações nas quais há uma alta taxa de incerteza e alta variabilidade sobre o trabalho que precisará ser executado.
* Tende a se espalhar rapidamente por toda a organização e para outros departamentos, como por exemplo, RH.

* Trabalhar com iterações no Kanban é algo opcional, faça tal controle de tempo caso o seu contexto exija. O mesmo se aplica para as estimativas. Dado que a sua equipe passou a medir, utilize os dados do passado como referência para desenhar cenários futuros. Por fim, o Kanban é apenas uma ferramenta para a gestão do fluxo de trabalho e, por isso, dificilmente ela substituirá qualquer outro tipo de ferramente que alicerce a forma com o é construído software.

* Toda equipe que adota o Scrum deve estar sustentada por três pilares. O primeiro deles é a transparência, que tem como objetivo dar clareza e visibilidade sobre o trabalho que está sendo desenvolvido para todas as partes envolvidas.

* O segundo pilar é a inspeção, que visa reforçar a ideia de que todo trabalho deve ser inspecionado com a frequência necessária para que haja a garantia da qualidade no produto final. O terceiro último pilar é a adaptação, que visa instigar a filosofia de melhoria contínua em todo o trabalho que é conduzido pela equipe com o objetivo de se atingir melhores resultados.

<h3>Benefícios do Scrum</h3>

* Criar uma organização estruturada em equipes pequenas, multifuncionais e auto-organizadas.
* Ter clareza do trabalho necessário a partir de uma lista de entregas pequenas, concretas e priorizadas.
* Dividir o ciclo de trabalho da equipe em períodos de tempo fixo, garantido uma maior frequência de entrega dentro de um espaço de tempo, o que pode trazer como resultado uma previsibilidade na cadência de entrega.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Promover melhorias no processo a partir de retrospectivas realizadas ao final de cada sprint.

<h3>Boas práticas de engenharia de software</h3>

* Equipe unida;
* Planejamento contínuo;
* Entregas curtas;
* Testes a partir da visão do cliente;
* Propriedade coletiva do código;
* Padronização de código;
* Ritmo de entrega sustentável;
* Metáforas para compartilhar conceitos gerais sobre o software criado;
* Integração contínua;
* Desenvolvimento orientado a testes;
* Melhoria da qualidade do código existente;
* Simplicidade no software escrito e programação em par;
* Design Incremental;
* Colaboração no código;

<h3>Crie seu processo de desenvolvimento de forma madura</h3>

Durante a década de 1980, o físico israelense Eliyahu Goldratt criou uma teoria chamada Teoria das Restrições, também conhecida como TOC. A TOC é baseada em três pressupostos: uma organização possui uma meta a ser atingida; uma organização é mais que a soma de suas partes; e o desempenho de uma organização é limitado por poucas variáveis ditas restrições do sistema.

Existem cinco etapas decorrentes desses pressupostos:

* Identificar as restrições do sistema;
* Decidir como explorá-las;
* Subordinar tudo o mais à decisão anterior;
* Elevar as restrições do sistema;
* Voltar à primeira etapa sem permitir que a inércia cause uma nova restrição;

* Trazendo o conceito colocado por Goldratt para o processo de uma equipe que desenvolve software é como se passássemos a olhar o fluxo de trabalho a partir de uma visão sistêmica, isto é, enxergando-o como um fluxo contínuo em vez de segmentá-lo em diversas unidades independentes (como desenvolvimento, testes e publicação são etapas de um mesmo processo, e não unidades independentes). Isso garante que todo o sistema esteja alinhado com uma única meta (no caso de uma equipe de entregar software de forma ágil) e permite que os gargalos possam ser trabalhados para atingi-la mais facilmente.

* Imagine que a equipe XPTO possui as etapas de A fazer, Em desenvolvimento, Em Testes, Em Aprovação e Finalizado. Uma estratégia que poderia ser adotada é a de criar etapas sinalizando o aguardo de uma demanda.

* A segunda dica ao construir o seu processo é: evite criar um ambiente orientado a tarefas e favoreça um ambiente a missão.

<h3>A Importância de Analisar o Trabalho em Progresso</h3>

* O WIP refere-se a todos os materiais e produtos parcialmente acabados que estão em diferentes estágios do fluxo de desenvolvimento. Para o contexto do trabalhador do conhecimento, o WIP geralmente se traduz em uma demanda importante que foi começada, mas que ainda não está fornecendo valor para o cliente. Essencialmente é um investimento que não gera retorno, e se deprecia com o passar do tempo.

* Independente do processo que o seu time estiver usando, só será possível identificar a quantidade de trabalho em progresso a partir do momento em que estiverem claras as etapas de entrada e saída do processo.

* Medir o WIP é um dos trabalhos mais importantes no monitoramento da saúde do processo de desenvolvimento de software, pois, como veremos nos próximos capítulos, ele é um dos preditores do desempenho geral do fluxo de desenvolvimento. Gerenciando o WIP, garantimos um controle na cadência das entregas e impactamos o tempo que uma demanda passará pelo fluxo de desenvolvimento.



