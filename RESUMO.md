# Métricas Ágeis
<h2>Obtenha melhores resultados em sua equipe</h2>

“Metrificar é o primeiro passo para o controle e eventualmente para melhoria. Se você não consegue medir algo, você não consegue entendê-lo. Se você não consegue capturá-lo, você não consegue controlá-lo. Se você não consegue controlá-lo, você não consegue melhorá-lo”. 
<b>HARRIGTON, H. James.</b>

<h3>Comparação de construção de software com elaboração de um artefato científico</h3>

* Observar o fenômeno = Problema de negócio.
* Formular uma hipótese para explicar o fenômeno = Funcionalidades que resolverão o problema de negócio.
* Usar a hipótese para fazer uma predição = Suposições de utilidade do produto no mundo real
* Testar a predição através de experimentos ou novas observações, e modificar a hipótese com base nos resultados do teste = Pegar o feedback e dar uma nova diretiva

<h3>Planejamento, Execução, Verificação = Ação</h3>

* Uma das grandes dificuldades que as equipes têm ao construírem uma solução é a de compreenderem como ela se conecta com os objetivos de negócio de uma organização. Como reflexo de tal desalinhamento, temos situações nas quais são criadas soluções em que grande parte das funcionalidades raramente ou nunca utilizadas.

* Se você trabalha em um ambiente que não conta com um processo para se construir software, é bem provável que você lide com desafios na qualidade do produto final, na organização e otimização dos recursos, e no planejamento do que será entregue. É melhor se ter um processo com suas limitações e que pode ser evoluído do que trabalhar em um local caótico.

* Enquanto no modelo tradicional existe uma separação entre as etapas necessárias para a construção de um software, no modelo ágil tal separação não existe, dado que há uma multidisciplinaridade das pessoas envolvidas na criação da solução.

* Uma das grandes diferenças entre as abordagens de desenvolvimento de software ágil e tradicional diz respeito a qualidade e testes. Ao passo que, no modelo tradicional, a fase de teste vem depois da fase de construção, na abordagem ágil, os testes são feitos concomitantemente com o desenvolvimento.

* O modelo tradicional não serve para nenhum caso? Depende. Se você está lidando com situações nas quais há uma clareza nas funcionalidades que precisarão ser construídas e que não haverá qualquer tipo de mudança no que se espera com o produto final, utilizar um modelo tradicional pode ser mais eficiente. Agora, dada a natureza da incerteza que envolve o desenvolvimento de software e sabendo que a única certeza é que existirão mudanças, é aconselhável se pensar em seguir o processo ágil.

<h3>Kanban</h3>

Em 2010 David Anderson criou o que ele chamou de “sistema Kanban para desenvolvimento de software”, que combina o pensamento lean e a teoria das restrições.

* <b>Comece com o que você já faz hoje:</b> Crie formas de visibilidade e busque evoluir o processo.
* <b>Busque mudanças incrementais:</b> Melhore sempre sem ser radical.
* <b>Respeite o processo atual, seus papéis, responsabilidades e cargos:</b> Faça melhorias evolutivas e não seja disruptivo.
* <b>Visualize o fluxo de trabalho:</b> Divida o trabalho em partes, escreva cada demanda em um cartão e tenha visão de todo o trabalho em andamento.
* <b>Limite o trabalho em progresso:</b> Atribua limites explícitos para a quantidade de itens que podem estar em andamento em cada etapa do fluxo de trabalho.
* <b>Torne as políticas explícitas:</b> Defina, divulgue e socialize o processo, assim todos terão uma clareza de como funciona e de como o trabalho é realmente feito.
* <b>Desenvolva loops de feedback:</b> Reduza o tempo do ciclo de feedback, pois quanto mais tardia a entrega, mais demorada será a geração de valor daquilo que foi trabalhado.
* <b>Melhore de forma colaborativa:</b> Exerça a filosofia de melhoria contínua baseada no kaizen.

<h3>Benefícios Kanban</h3>

* Os gargalos do processo ficarão visíveis em tempo real, o que levará as pessoas a colaborarem para otimizar toda a cadeia de valor em vez de olhar apenas para a sua parte.
* Provê um caminho mais ameno quando a organização está em um processo de transição de uma abordagem tradicional para uma abordagem de desenvolvimento de software ágil.
* Fornece uma maneira de criar software de forma ágil sem necessariamente lidar com iterações de tempo fixo, como por exemplo, as sprints do Scrum.
* Útil para situações nas quais há uma alta taxa de incerteza e alta variabilidade sobre o trabalho que precisará ser executado.
* Tende a se espalhar rapidamente por toda a organização e para outros departamentos, como por exemplo, RH.

* Trabalhar com iterações no Kanban é algo opcional, faça tal controle de tempo caso o seu contexto exija. O mesmo se aplica para as estimativas. Dado que a sua equipe passou a medir, utilize os dados do passado como referência para desenhar cenários futuros. Por fim, o Kanban é apenas uma ferramenta para a gestão do fluxo de trabalho e, por isso, dificilmente ela substituirá qualquer outro tipo de ferramente que alicerce a forma com o é construído software.

* Toda equipe que adota o Scrum deve estar sustentada por três pilares. O primeiro deles é a transparência, que tem como objetivo dar clareza e visibilidade sobre o trabalho que está sendo desenvolvido para todas as partes envolvidas.

* O segundo pilar é a inspeção, que visa reforçar a ideia de que todo trabalho deve ser inspecionado com a frequência necessária para que haja a garantia da qualidade no produto final. O terceiro último pilar é a adaptação, que visa instigar a filosofia de melhoria contínua em todo o trabalho que é conduzido pela equipe com o objetivo de se atingir melhores resultados.

<h3>Benefícios do Scrum</h3>

* Criar uma organização estruturada em equipes pequenas, multifuncionais e auto-organizadas.
* Ter clareza do trabalho necessário a partir de uma lista de entregas pequenas, concretas e priorizadas.
* Dividir o ciclo de trabalho da equipe em períodos de tempo fixo, garantido uma maior frequência de entrega dentro de um espaço de tempo, o que pode trazer como resultado uma previsibilidade na cadência de entrega.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Promover melhorias no processo a partir de retrospectivas realizadas ao final de cada sprint.

<h3>Boas práticas de engenharia de software</h3>

* Equipe unida;
* Planejamento contínuo;
* Entregas curtas;
* Testes a partir da visão do cliente;
* Propriedade coletiva do código;
* Padronização de código;
* Ritmo de entrega sustentável;
* Metáforas para compartilhar conceitos gerais sobre o software criado;
* Integração contínua;
* Desenvolvimento orientado a testes;
* Melhoria da qualidade do código existente;
* Simplicidade no software escrito e programação em par;
* Design Incremental;
* Colaboração no código;

<h3>Crie seu processo de desenvolvimento de forma madura</h3>

Durante a década de 1980, o físico israelense Eliyahu Goldratt criou uma teoria chamada Teoria das Restrições, também conhecida como TOC. A TOC é baseada em três pressupostos: uma organização possui uma meta a ser atingida; uma organização é mais que a soma de suas partes; e o desempenho de uma organização é limitado por poucas variáveis ditas restrições do sistema.

Existem cinco etapas decorrentes desses pressupostos:

* Identificar as restrições do sistema;
* Decidir como explorá-las;
* Subordinar tudo o mais à decisão anterior;
* Elevar as restrições do sistema;
* Voltar à primeira etapa sem permitir que a inércia cause uma nova restrição;

* Trazendo o conceito colocado por Goldratt para o processo de uma equipe que desenvolve software é como se passássemos a olhar o fluxo de trabalho a partir de uma visão sistêmica, isto é, enxergando-o como um fluxo contínuo em vez de segmentá-lo em diversas unidades independentes (como desenvolvimento, testes e publicação são etapas de um mesmo processo, e não unidades independentes). Isso garante que todo o sistema esteja alinhado com uma única meta (no caso de uma equipe de entregar software de forma ágil) e permite que os gargalos possam ser trabalhados para atingi-la mais facilmente.

* Imagine que a equipe XPTO possui as etapas de A fazer, Em desenvolvimento, Em Testes, Em Aprovação e Finalizado. Uma estratégia que poderia ser adotada é a de criar etapas sinalizando o aguardo de uma demanda.

* A segunda dica ao construir o seu processo é: evite criar um ambiente orientado a tarefas e favoreça um ambiente a missão.

<h3>A Importância de Analisar o Trabalho em Progresso</h3>

* O WIP refere-se a todos os materiais e produtos parcialmente acabados que estão em diferentes estágios do fluxo de desenvolvimento. Para o contexto do trabalhador do conhecimento, o WIP geralmente se traduz em uma demanda importante que foi começada, mas que ainda não está fornecendo valor para o cliente. Essencialmente é um investimento que não gera retorno, e se deprecia com o passar do tempo.

* Independente do processo que o seu time estiver usando, só será possível identificar a quantidade de trabalho em progresso a partir do momento em que estiverem claras as etapas de entrada e saída do processo.

* Medir o WIP é um dos trabalhos mais importantes no monitoramento da saúde do processo de desenvolvimento de software, pois, como veremos nos próximos capítulos, ele é um dos preditores do desempenho geral do fluxo de desenvolvimento. Gerenciando o WIP, garantimos um controle na cadência das entregas e impactamos o tempo que uma demanda passará pelo fluxo de desenvolvimento.

* Foque os esforços para diminuir o estoque da etapa de gargalo;
* Não aumente o WIP até que a etapa do gargalo esteja em um nível saudável, afinal, ela determinará a capacidade de vazão do processo;
* Podemos ter uma maior previsibilidade de qual é a capacidade de trabalho do time em qualquer espaço de tempo;
* Reduzimos a quantidade de trabalho “quase pronto”, forçando o time a se concentrar em um conjunto menor de tarefa e incentivando a cultura de “pronto”;
* Gargalos e bloqueios ficarão visíveis e serão destacados antes de uma situação se tornar difícil de ser gerenciada. Uma vez que os bloqueios são removidos, o trabalho de toda a equipe começa a fluir novamente;
* Quanto mais trabalho colocamos dentro do fluxo de desenvolvimento do time, menor será a qualidade;

* Estimule os membros do time a enxergarem que eles não estão parados, mas sim que ganharam tempo para olhar o fluxo de desenvolvimento como um todo e que estão aptos a alocar o esforço disponível em algum lugar que esteja precisando de apoio.

* Podemos concluir que o Scrum limita o WIP indiretamente, enquanto o Kanban limita o WIP diretamente. Além disso podemos dizer que o Scrum limita o WIP por unidade de tempo, enquanto o Kanban limita o WIP por etapa de fluxo de trabalho.

* Story Mapping é uma técnica colaborativa que auxilia na priorização e no planejamento de releases de produtos interativos.

* Para Pichler (2010) sobre o que caracteriza uma demanda pronta para ser trabalhada. O autor diz que qualquer demanda, para ser considerada pronta para ser desenvolvida, deve ser clara, confiável e testável.

<h3>Questões orientadoras</h3>

* Qual o problema a ser resolvido?
* Qual o resultado esperado?
* Existe alguma dependência de negócio ou técnica para esta demanda?
* A demanda depende de alguma definição visual?
* Quais são os critérios de aceite que garantirão a verificação e a validação da demanda?
* Existe algum requisito não funcional (exemplo: performance, design) que deve ser atendido?

<h3>Critérios para definir se uma demanda está pronta para ser trabalhada</h3>

* Demanda definida e escrita;
* Critérios de aceite definidos e compreendidos por todos do time;
* Dependências identificadas;
* Informações de interfaces definidas (quando necessário);
* Critérios de desempenho definidos (quando necessário);
* Existência de um alinhamento entre as partes que construirão e avaliarão a demanda;

* Mike Cohn, define que uma história de usuário com qualidade deve seguir os critérios agrupados no acrônimo INVEST. O autor defende que, se a história falhar em algum dos critérios, o time deverá repensá-la ou até mesmo reescrevê-la.

* <b>Independent (Independente):</b> histórias devem ser independentes uma das outras sempre que possível, para que seja fácil priorizá-las.
* <b>Negotiable (Negociável):</b> histórias não são contratos para implementar funcionalidades. Boas histórias captam a essência e não os detalhes.
* <b>Valuable (Tenha valor):</b> se uma história não tem valor perceptível, ela não deve ser feita.
* <b>Estimable (Estimável):</b> toda história tem de ser estimável e dimensionável, me modo  que possa ser convenientemente priorizada.
* <b>Small (Pequena):</b> boas histórias são pequenas, pois são mais fáceis de se estimar e planejar.
* <b>Testable (Testável):</b> os testes demonstram que uma história alcançou as expectativas dos usuários/clientes.








