# Métricas Ágeis
<h2>Obtenha melhores resultados em sua equipe</h2>

“Metrificar é o primeiro passo para o controle e eventualmente para melhoria. Se você não consegue medir algo, você não consegue entendê-lo. Se você não consegue capturá-lo, você não consegue controlá-lo. Se você não consegue controlá-lo, você não consegue melhorá-lo”. 
<b>HARRIGTON, H. James.</b>

<h3>Comparação de construção de software com elaboração de um artefato científico</h3>

* Observar o fenômeno = Problema de negócio.
* Formular uma hipótese para explicar o fenômeno = Funcionalidades que resolverão o problema de negócio.
* Usar a hipótese para fazer uma predição = Suposições de utilidade do produto no mundo real
* Testar a predição através de experimentos ou novas observações, e modificar a hipótese com base nos resultados do teste = Pegar o feedback e dar uma nova diretiva

<h3>Planejamento, Execução, Verificação = Ação</h3>

* Uma das grandes dificuldades que as equipes têm ao construírem uma solução é a de compreenderem como ela se conecta com os objetivos de negócio de uma organização. Como reflexo de tal desalinhamento, temos situações nas quais são criadas soluções em que grande parte das funcionalidades raramente ou nunca utilizadas.

* Se você trabalha em um ambiente que não conta com um processo para se construir software, é bem provável que você lide com desafios na qualidade do produto final, na organização e otimização dos recursos, e no planejamento do que será entregue. É melhor se ter um processo com suas limitações e que pode ser evoluído do que trabalhar em um local caótico.

* Enquanto no modelo tradicional existe uma separação entre as etapas necessárias para a construção de um software, no modelo ágil tal separação não existe, dado que há uma multidisciplinaridade das pessoas envolvidas na criação da solução.

* Uma das grandes diferenças entre as abordagens de desenvolvimento de software ágil e tradicional diz respeito a qualidade e testes. Ao passo que, no modelo tradicional, a fase de teste vem depois da fase de construção, na abordagem ágil, os testes são feitos concomitantemente com o desenvolvimento.

* O modelo tradicional não serve para nenhum caso? Depende. Se você está lidando com situações nas quais há uma clareza nas funcionalidades que precisarão ser construídas e que não haverá qualquer tipo de mudança no que se espera com o produto final, utilizar um modelo tradicional pode ser mais eficiente. Agora, dada a natureza da incerteza que envolve o desenvolvimento de software e sabendo que a única certeza é que existirão mudanças, é aconselhável se pensar em seguir o processo ágil.

<h3>Kanban</h3>

Em 2010 David Anderson criou o que ele chamou de “sistema Kanban para desenvolvimento de software”, que combina o pensamento lean e a teoria das restrições.

* <b>Comece com o que você já faz hoje:</b> Crie formas de visibilidade e busque evoluir o processo.
* <b>Busque mudanças incrementais:</b> Melhore sempre sem ser radical.
* <b>Respeite o processo atual, seus papéis, responsabilidades e cargos:</b> Faça melhorias evolutivas e não seja disruptivo.
* <b>Visualize o fluxo de trabalho:</b> Divida o trabalho em partes, escreva cada demanda em um cartão e tenha visão de todo o trabalho em andamento.
* <b>Limite o trabalho em progresso:</b> Atribua limites explícitos para a quantidade de itens que podem estar em andamento em cada etapa do fluxo de trabalho.
* <b>Torne as políticas explícitas:</b> Defina, divulgue e socialize o processo, assim todos terão uma clareza de como funciona e de como o trabalho é realmente feito.
* <b>Desenvolva loops de feedback:</b> Reduza o tempo do ciclo de feedback, pois quanto mais tardia a entrega, mais demorada será a geração de valor daquilo que foi trabalhado.
* <b>Melhore de forma colaborativa:</b> Exerça a filosofia de melhoria contínua baseada no kaizen.

<h3>Benefícios Kanban</h3>

* Os gargalos do processo ficarão visíveis em tempo real, o que levará as pessoas a colaborarem para otimizar toda a cadeia de valor em vez de olhar apenas para a sua parte.
* Provê um caminho mais ameno quando a organização está em um processo de transição de uma abordagem tradicional para uma abordagem de desenvolvimento de software ágil.
* Fornece uma maneira de criar software de forma ágil sem necessariamente lidar com iterações de tempo fixo, como por exemplo, as sprints do Scrum.
* Útil para situações nas quais há uma alta taxa de incerteza e alta variabilidade sobre o trabalho que precisará ser executado.
* Tende a se espalhar rapidamente por toda a organização e para outros departamentos, como por exemplo, RH.

* Trabalhar com iterações no Kanban é algo opcional, faça tal controle de tempo caso o seu contexto exija. O mesmo se aplica para as estimativas. Dado que a sua equipe passou a medir, utilize os dados do passado como referência para desenhar cenários futuros. Por fim, o Kanban é apenas uma ferramenta para a gestão do fluxo de trabalho e, por isso, dificilmente ela substituirá qualquer outro tipo de ferramente que alicerce a forma com o é construído software.

* Toda equipe que adota o Scrum deve estar sustentada por três pilares. O primeiro deles é a transparência, que tem como objetivo dar clareza e visibilidade sobre o trabalho que está sendo desenvolvido para todas as partes envolvidas.

* O segundo pilar é a inspeção, que visa reforçar a ideia de que todo trabalho deve ser inspecionado com a frequência necessária para que haja a garantia da qualidade no produto final. O terceiro último pilar é a adaptação, que visa instigar a filosofia de melhoria contínua em todo o trabalho que é conduzido pela equipe com o objetivo de se atingir melhores resultados.

<h3>Benefícios do Scrum</h3>

* Criar uma organização estruturada em equipes pequenas, multifuncionais e auto-organizadas.
* Ter clareza do trabalho necessário a partir de uma lista de entregas pequenas, concretas e priorizadas.
* Dividir o ciclo de trabalho da equipe em períodos de tempo fixo, garantido uma maior frequência de entrega dentro de um espaço de tempo, o que pode trazer como resultado uma previsibilidade na cadência de entrega.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Otimizar o planejamento do produto que está sendo construído a partir da colaboração com os usuários e clientes, baseado no aprendizado obtido nas entregas passadas.
* Promover melhorias no processo a partir de retrospectivas realizadas ao final de cada sprint.

<h3>Boas práticas de engenharia de software</h3>

* Equipe unida;
* Planejamento contínuo;
* Entregas curtas;
* Testes a partir da visão do cliente;
* Propriedade coletiva do código;
* Padronização de código;
* Ritmo de entrega sustentável;
* Metáforas para compartilhar conceitos gerais sobre o software criado;
* Integração contínua;
* Desenvolvimento orientado a testes;
* Melhoria da qualidade do código existente;
* Simplicidade no software escrito e programação em par;
* Design Incremental;
* Colaboração no código;

<h3>Crie seu processo de desenvolvimento de forma madura</h3>

Durante a década de 1980, o físico israelense Eliyahu Goldratt criou uma teoria chamada Teoria das Restrições, também conhecida como TOC. A TOC é baseada em três pressupostos: uma organização possui uma meta a ser atingida; uma organização é mais que a soma de suas partes; e o desempenho de uma organização é limitado por poucas variáveis ditas restrições do sistema.

Existem cinco etapas decorrentes desses pressupostos:

* Identificar as restrições do sistema;
* Decidir como explorá-las;
* Subordinar tudo o mais à decisão anterior;
* Elevar as restrições do sistema;
* Voltar à primeira etapa sem permitir que a inércia cause uma nova restrição;

* Trazendo o conceito colocado por Goldratt para o processo de uma equipe que desenvolve software é como se passássemos a olhar o fluxo de trabalho a partir de uma visão sistêmica, isto é, enxergando-o como um fluxo contínuo em vez de segmentá-lo em diversas unidades independentes (como desenvolvimento, testes e publicação são etapas de um mesmo processo, e não unidades independentes). Isso garante que todo o sistema esteja alinhado com uma única meta (no caso de uma equipe de entregar software de forma ágil) e permite que os gargalos possam ser trabalhados para atingi-la mais facilmente.

* Imagine que a equipe XPTO possui as etapas de A fazer, Em desenvolvimento, Em Testes, Em Aprovação e Finalizado. Uma estratégia que poderia ser adotada é a de criar etapas sinalizando o aguardo de uma demanda.

* A segunda dica ao construir o seu processo é: evite criar um ambiente orientado a tarefas e favoreça um ambiente a missão.

<h3>A Importância de Analisar o Trabalho em Progresso</h3>

* O WIP refere-se a todos os materiais e produtos parcialmente acabados que estão em diferentes estágios do fluxo de desenvolvimento. Para o contexto do trabalhador do conhecimento, o WIP geralmente se traduz em uma demanda importante que foi começada, mas que ainda não está fornecendo valor para o cliente. Essencialmente é um investimento que não gera retorno, e se deprecia com o passar do tempo.

* Independente do processo que o seu time estiver usando, só será possível identificar a quantidade de trabalho em progresso a partir do momento em que estiverem claras as etapas de entrada e saída do processo.

* Medir o WIP é um dos trabalhos mais importantes no monitoramento da saúde do processo de desenvolvimento de software, pois, como veremos nos próximos capítulos, ele é um dos preditores do desempenho geral do fluxo de desenvolvimento. Gerenciando o WIP, garantimos um controle na cadência das entregas e impactamos o tempo que uma demanda passará pelo fluxo de desenvolvimento.

* Foque os esforços para diminuir o estoque da etapa de gargalo;
* Não aumente o WIP até que a etapa do gargalo esteja em um nível saudável, afinal, ela determinará a capacidade de vazão do processo;
* Podemos ter uma maior previsibilidade de qual é a capacidade de trabalho do time em qualquer espaço de tempo;
* Reduzimos a quantidade de trabalho “quase pronto”, forçando o time a se concentrar em um conjunto menor de tarefa e incentivando a cultura de “pronto”;
* Gargalos e bloqueios ficarão visíveis e serão destacados antes de uma situação se tornar difícil de ser gerenciada. Uma vez que os bloqueios são removidos, o trabalho de toda a equipe começa a fluir novamente;
* Quanto mais trabalho colocamos dentro do fluxo de desenvolvimento do time, menor será a qualidade;

* Estimule os membros do time a enxergarem que eles não estão parados, mas sim que ganharam tempo para olhar o fluxo de desenvolvimento como um todo e que estão aptos a alocar o esforço disponível em algum lugar que esteja precisando de apoio.

* Podemos concluir que o Scrum limita o WIP indiretamente, enquanto o Kanban limita o WIP diretamente. Além disso podemos dizer que o Scrum limita o WIP por unidade de tempo, enquanto o Kanban limita o WIP por etapa de fluxo de trabalho.

* Story Mapping é uma técnica colaborativa que auxilia na priorização e no planejamento de releases de produtos interativos.

* Para Pichler (2010) sobre o que caracteriza uma demanda pronta para ser trabalhada. O autor diz que qualquer demanda, para ser considerada pronta para ser desenvolvida, deve ser clara, confiável e testável.

<h3>Questões orientadoras</h3>

* Qual o problema a ser resolvido?
* Qual o resultado esperado?
* Existe alguma dependência de negócio ou técnica para esta demanda?
* A demanda depende de alguma definição visual?
* Quais são os critérios de aceite que garantirão a verificação e a validação da demanda?
* Existe algum requisito não funcional (exemplo: performance, design) que deve ser atendido?

<h3>Critérios para definir se uma demanda está pronta para ser trabalhada</h3>

* Demanda definida e escrita;
* Critérios de aceite definidos e compreendidos por todos do time;
* Dependências identificadas;
* Informações de interfaces definidas (quando necessário);
* Critérios de desempenho definidos (quando necessário);
* Existência de um alinhamento entre as partes que construirão e avaliarão a demanda;

Mike Cohn, define que uma história de usuário com qualidade deve seguir os critérios agrupados no acrônimo INVEST. O autor defende que, se a história falhar em algum dos critérios, o time deverá repensá-la ou até mesmo reescrevê-la.

* <b>Independent (Independente):</b> histórias devem ser independentes uma das outras sempre que possível, para que seja fácil priorizá-las.
* <b>Negotiable (Negociável):</b> histórias não são contratos para implementar funcionalidades. Boas histórias captam a essência e não os detalhes.
* <b>Valuable (Tenha valor):</b> se uma história não tem valor perceptível, ela não deve ser feita.
* <b>Estimable (Estimável):</b> toda história tem de ser estimável e dimensionável, me modo  que possa ser convenientemente priorizada.
* <b>Small (Pequena):</b> boas histórias são pequenas, pois são mais fáceis de se estimar e planejar.
* <b>Testable (Testável):</b> os testes demonstram que uma história alcançou as expectativas dos usuários/clientes.

<h3>Identifique o tempo para a entrega de uma demanda</h3>

* Conviver em um ambiente no qual clientes, usuários e equipe não possuem visibilidade sobre o tempo que é necessário para que determinado trabalho seja concluído gera desconfiança, dúvida, ruído na comunicação e, principalmente, a sensação de que tudo poderia ser feito mais rápido.

* Se você lida no dia a dia com demandas que levam muito tempo e outras que acabam rápido demais, saiba que tal variabilidade é um grande ofensor quando se está em busca de um processo previsível, e dificilmente você conseguirá prever entregas futuras.

* Para a indústria, lead time representa a latência entre a iniciação e a execução de um processo. No setor de bens industriais, a redução de tal métrica representa um aspecto-chave da manufatura enxuta (lean manufacturing).

* No contexto de desenvolvimento de software, podemos considerar o lead time como sendo o número de dias entre o início e o fim do processo de entrega de um item de trabalho (por exemplo, história do usuário, bugs etc).

* A mensuração do lead time no desenvolvimento de software passou a ganhar notoriedade quando David Anderson, criador do método Kanban, trouxe à tona a importância de coletar a métrica. No entanto, medi-la independe do método de trabalho que está sendo adotado.

<h3>Medir lead time é útil para:</h3>

* Compreender quanto tempo a equipe tem levado para desenvolver um item de trabalho;
* Analisar a saúde do processo de desenvolvimento dado que altas dispersões representam algum tipo de gargalo ou aumento no tempo de passagem em alguma etapa do fluxo de desenvolvimento (exemplo: nas últimas duas semanas lead time das histórias de desenvolvimento cresceram, pois o ambiente de homologação estava com problemas e os testes eram mais complexos);
* Identificar casos extremos (do inglês, outliers) e aprender com o ocorrido (exemplo: determinando bug levou muito mais tempo do que o normal para ser corrigido em decorrência da ausência de clareza sobre o que era de fato problema a ser resolvido);
* Analisar se a equipe tem entregue os itens de trabalho dentro de um padrão de dias ou semanas (exemplo: a maioria das histórias de usuário da equipe estão dentro de um período de 2 semanas);
* Para compreender os efeitos que as incertezas e as complexidades não mapeadas podem causar, na forma da variabilidade, no tempo necessário para conclusão dos itens de trabalho de uma equipe de desenvolvimento de software;

Caso você esteja em um contexto em que o software já é um produto e precisa de evoluções e correções de falhas, e que o feedback do usuário e o tempo de resposta ao mercado são aspectos extremamente sensíveis, medir o lead time considerando dias corridos é importante.

* A métrica levará em consideração os atrasos e o tempo gasto em espera gerado pelos finais de semana, feriados e dias não úteis. Podemos dizer que a métrica refletirá de fato a dor do cliente no caso de um bug não resolvido no sábado, ou perda da oportunidade de disponibilizar, em um feriado uma nova funcionalidade frente à concorrência.

* Outro motivador para que você meça o lead time em dias corridos é de que ele representa o tempo necessário para se coletar feedback do cliente ou usuário, algo tão importante para quem trabalho no universo do conhecimento. Valor por si só é, em última instância, determinado pelo cliente, o que quer dizer que a equipe buscará ter certeza de estar recebendo feedback do valor gerado o mais rápido possível. A última coisa que você equipe buscam é criar algo que o cliente não precisa. Diminuindo o lead time, reduzimos o ciclo de feedback com nossos clientes.

* Dada a consideração de todo tipo de espera, as projeções de entrega de um item (como falha, funcionalidade etc) a partir do histórico de lead time, serão mais previsíveis. Por exemplo, se um bug tem por padrão demorar 3 dias para ser corrigido e foi descoberta uma falha grave na quarta-feira, a equipe terá maior certeza de que, sendo iniciada na quinta-feira, até sábado o problema estará sanado e que ações específicas podem ser tomadas para tratar o caso, como, por exemplo: pessoas trabalhando um tempo extra durante a semana; redução nas etapas de aprovação de um deploy; priorização máxima nos testes etc.

* As decisões que serão tomadas a partir do lead time levarão em consideração aspectos extras no fluxo de desenvolvimento da equipe e estarão relacionadas intimamente ao negócio. Por exemplo, quantos clientes meu produto perdeu por conta de determinado bug não ter sido resolvido mais rápido? Quantos clientes não aderiram ao produto por não termos colocado determinada funcionalidade em produção antes?

<h3>Lead time dias úteis</h3>
 
* Produto de software em desenvolvimento;
* Melhorias centradas no processo de desenvolvimento da equipe;
* Ainda não existe feedback do usuário;
* Atraso influenciando o prazo de entrega;
 
<h3>Lead time dias corridos</h3>
 
* Produto de software em produção;
* Melhorias em todo o fluxo, inclusive em esperas externas (ex: finais de semana);
* Feedback do usuário é importante;
* Atraso influenciado a perda de clientes atuais, a perda de oportunidades de mercado por conta da concorrência e a perda da credibilidade do produto;

* Se vocẽ deseja que sua equipe não sofra com variações no lead time por conta de indefinições, antes que a equipe assuma o desenvolvimento de qualquer trabalho, proponha que ela responda às seguintes questões:

* Qual o problema que precisamos resolver?
* Qual o resultado esperado por quem demandou (como usuário)?
* Existe alguma dependência de negócio ou ténica para esta demanda (integrações externas)? 
* Existe algum tipo de informação de interface importante para que a demanda seja desenvolvida?
* Os critérios para que haja o aceita da demanda são claros?

Uma técnica que tem sido útil para aumentar o processo de aprendizado de novos membros é o pair programming. Com o passar dos anos, tenho observado algumas vantagens ao se adotar tal prática, como:

* Aumento da atenção no processo de codificação, há uma queda no número de distrações e interrupções desnecessárias;
* As pessoas ficam mais atentas aos padrões de qualidade de código definidos;
* A necessidade de refatoração diminui;
* Há um aumento da qualidade dos testes que são realizados;
* Os desenvolvedores trocam conhecimento, o que gera soluções otimizadas e criativas;

Ao iniciar o trabalho de análise do lead time de uma equipe, geralmente, começo de um conjunto de variáveis oriundas da estatística descritiva e que são comuns em nosso linguajar. São elas: média, moda, mediana e percentil.

* Para extrairmos a média de um conjunto de dados numéricos, precisamos somar os valores de todos os dados e dividi-los pela quantidade de dados.

* A moda é o valor mais frequente de um conjunto de dados.

* A mediana nada mais é do que uma medida de localização do centro da distribuição dos dados, definida da seguinte maneira: ordenados os elementos do conjunto de dados, a mediana é o valor que o divide ao meio, isto é, 50% dos elementos do conjunto de dados são menores ou iguais à mediana e os outros 50% são maiores ou iguais a ela.

* Ainda sobre medidas de localização, definimos que os percentis são medidas que dividem a amostra ordenada em 100 partes, cada uma com uma percentagem de dados aproximadamente igual. Quando dizemos que o percentil 75 possui o valor 7, estamos afirmando que 75% do conjunto de dados possui um valor inferior ou igual a 7, ou que 25% do conjunto possui um valor superior a 7.

Venho observando alguns fatores que acabam sendo responsáveis por gerar situações de casos extremos e que você, assim como eu, já deve ter lidado em seu dia a dia. São eles:

* Problema externos ao desenvolvimento da demanda que são mapeados tardiamente (exemplo: integrações com sistemas externos que não funcionam ou ambientes que não estão disponíveis quando necessário);
* Dependência de terceiros para a finalização de uma entrega (exemplo: o desenvolvimento de uma funcionalidade exige o trabalho de design, mas o especialista não faz parte da equipe);
* Falta de definição do que se espera como resultado de uma demanda (exemplo: ausência de critérios na etapa de validação de uma funcionalidade ou da correção de um bug);
* Mudança no escopo de uma demanda ao longo do desenvolvimento (exemplo: o escopo de uma funcionalidade absorve mais do que era esperado inicialmente por ela);
* Subestimação da complexidade do desenvolvimento de uma demanda (exemplo: a equipe, de forma extremamente otimista, assume o desenvolvimento de uma entrega sem ponderar sua complexidade técnica ou de negócios, ou a equipe inicia o desenvolvimento de uma história de usuário mal dimensionada);

<h3>Dicas para correção dos problemas acima</h3>

* Faça um trabalho de mentoria com o gestor do produto para que haja uma padronização na complexidade dos itens de trabalho;
* Traga ferramentas para que a equipe diminua a complexidade e remova as incertezas técnica ou de negócios dos itens que serão trabalhados;
* Analise a distribuição de lead time com frequência. No início do desenvolvimento de um projeto ou produto, a alta variabilidade do lead time será normal, porém, após algum tempo, é importante buscar um padrão;
* Comunique aos stakeholders de um projeto ou produto qualquer a variação no lead time e desenvolva ações para controlar crescimentos;
* Use casos extremos como uma oportunidade para aprender e melhorar o seu processo;
* Limite o trabalho em progresso. Dessa forma, você estará monitorando o lead time de menos itens de trabalho e, consequentemente, melhorando a qualidade do que está sendo produzido pela equipe;

<h3>Medir o número de entregas de uma equipe</h3>

Depois de aprendermos a analisar o tempo que um item de trabalho leva para ser concluído (lead time) e a importância de monitorar o trabalho em progresso (WIP), neste capítulo teremos a oportunidade de conhecer a métrica chamada throughput. Você perceberá que a análise dela lhe ajudará a responder questões como:

* Quantas demandas a equipe está conseguindo entregar dentro de um espaço tempo?
* A equipe está vivendo um cenário no qual o número de entregas vem aumentando?
* Existe algum tipo de bloqueio atrapalhando a capacidade de entrega da equipe?

* Se a equipe em que você atua está lidando com uma entrega crica onde a data de entrega é uma variável sensível, monitore semanalmente o throughput para que seja possível propor melhorias e ações dentro de um curto espaço de tempo. Afinal, responder às mudanças o quanto antes será um fator crítico para que haja a entrega de valor dentro do prazo esperado.

* Uma dúvida que pode estar surgindo na sua cabeça neste momento é: throughput seria o sinônimo de velocidade, utilizada comumente em equipes que adotam o Kanban? A resposta é não. Velocidade conforme definição da Zheglov (2016), representa o total de story points entregues por uma equipe ao longo de uma iteração (sprint). Story points é uma medida usada por equipes na mensuração do esforço necessário para desenvolver determinado requisito, funcionalidade, história do usuário, bug etc.

* Já trabalhei com equipes nas quais o conceito de pronto girava em torno da liberação de uma funcionalidade em um ambiente de aprovação. O problema de se considerar algo entregue, mesmo sabendo que existam etapas posteriores, é a falsa impressão de progresso. Afinal, do que adianta 5 demandas “prontas” para serem aprovadas, mas, sem uma expectativa de quando elas de fato serão consumidas pelos clientes ou usuários? Portanto, sempre que possível, considere um item finalizado quando este estiver gerando valor para o seu negócio ou usuário final.

Antes de finalizar este tópico gostaria de compartilhar quatro situações que podem ocasionar uma queda no throughput.

* Itens de trabalho mal definidos - como histórias de usuários com critérios de aceite ruins;
* Débitos técnicos - como reescrever uma parte do software inesperadamente;
* Gargalos no processo - como equipe de testes sobrecarregada e fluxo de publicação com problemas;
* Mudança no escopo de um item de trabalho ao longo do desenvolvimento - como inserção de um requisito não funcional no meio de uma iteração;

<h3>Qual a relação entre WIP, Lead Time e Throughput?</h3>

* O tempo médio de um item no processo de desenvolvimento (lead time) é igual a divisão do número médio de itens no processo (WIP) pelo número médio de itens que saem do sistema por unidade de tempo (throughput).

L = W/A

L = Média do lead time
W = média de itens em WIP
A = Média de throughput

* A lei de Little, criada por John Little no início dos anos 60, tem relação com um conjunto de estudos desenvolvidos para compreender sistemas de fila. Segundo o próprio autor, um sistema de fila consiste em objetos discretos que podem ser chamados de itens, que chegam a alguma taxa em um sistema. Os itens podem ser carros em uma cabine de pedágio, pessoas em uma linha de um restaurante fast food, aviões em uma linha de produção ou instruções esperando para serem executadas em um computador.

* Na maioria dos casos, o serviço é o gargalo que cria a fila;

* Para exemplificar a aplicação da forma, Little usou o exemplo de um rack de vinho. Digamos que você tem um rack de vinho que, em média, tem 100 garrafas nele. Vamos ainda dizer que você reabastece o rack a uma taxa média de duas garrafas por semana. Tendo em mãos tais informações, podemos determinar quanto tempo, em média, uma determinada garrafa gasta alojada no rack. A partir da equação, temos que L é igual a 100 e A é igual a 2. Aplicando tais valores, temos que uma dada garrafa de vinho fica, em média, 50 semanas no rack;

As premissas da lei de Little são:

* Um sistema de filas estável - a média do WIP no início do período do cálculo deve ser muito próxima da média no final do período e a idade média dos itens que compõem o trabalho em progresso não deve estar mudando, nem para mais, nem para menos.
* Um período de tempo arbitrariamente longo sob observação para garantirmos que o processo estacionário - média, variância e estrutura de autocorrelação não mudam no decorrer do tempo Isto é o mesmo que dissermos que os dados estão em um plano liso, sem tendência, variância constante no decorrer do tempo, uma estrutura de autocorrelação constante no decorrer do tempo e nenhum flutuação periódica.
* Que o cálculo seja realizada usando unidades consistentes - por exemplo, se o tempo média de um item no sistema é expresso em dias, então o número de itens chegando ao sistem também deve ser declarado em termos de dias.

Algumas mudanças nas premissas são necessárias quando passamos a olhar a lei de Little sob a perspectiva de throughput e não a partir da taxa de entrada. Segundo Vacanti (2015) são elas:

* A entrada média ou taxa de chegada deve ser igual à taxa média de saída;
* Todo o trabalho que é iniciado será eventualmente concluído e sairá do sistema;
* A quantidade de WIP deve ser aproximadamente a mesma no início e no final do intervalo de tempo escolhido para o cálculo;
* A idade média do WIP não deve aumentar nem decrescer;
* Lead time, WIP e throughput devem ser medidos usando unidades consistentes;

Você como orientador do processo de sua equipe poderá seguir diretrizes como:

* Só iniciaremos um novo trabalho aproximadamente na mesma proporção em que terminarmos o que já está no processo.
* Colocaremos todos os esforços necessários para terminar qualquer trabalho iniciado e minimizaremos a possibilidade de se trabalhar com itens que possam ser descartáveis.
* Se o trabalho da equipe por ventura ficar bloqueado, faremos tudo o que pudermos para desbloqueá-lo o mais rápido possível.
Antes de trazermos um novo item de trabalho para o fluxo de desenvolvimento, analisaremos se existe algo em WIP que esteja com um lead time alto e daremos foco para finalizá-lo.

<h3>O uso do throughput a partir de um caso real</h3>

Se você deseja que a sua equipe seja eficiente e eficaz antes de assumir a entrega de qualquer trabalho, faça com que s pessoas pensem nas seguintes perguntas:

* Qual é o resultado esperado por quem está demandando?
* Conseguimos simplificar a solução para que possamos validá-la junto ao usuário final, evitando assim retrabalho?
* Quais os tipos de demandas o time vem lidando no seu dia a dia? O que é prioridade no momento?

* Como primeira dica para que a sua equipe não sofra os efeitos do aumento do lead time, reduza as incertezas das demandas. Quanto antes a equipe tirar dúvidas técnicas e de negócio, mais familiarizada com a solução ela estará. Descobrir problemas no início do desenvolvimento é mais barato do que em etapas futuras.

<h3>Visualizar o fluxo de desenvolvimento de um time ágil</h3>

* Mapear um fluxo que garanta o desenvolvimento de software em um ritmo sustentável, ou até mesmo que proteja as equipes das incessantes demandas geradas por diferentes facetas envolvidas na construção de um produto ou projeto, é um dos grandes desafios de Gestores, Agile Coaches, Scrum Master e time.

* O CFD (Cumulative Flow Diagram) é uma excelente forma de compreender o fluxo de trabalho ao longo de um processo, afinal, o gráfico pode nos dar um panorama geral do que está acontecendo durante o desenvolvimento de um projeto ou produto.

* A estrutura do gráfico é muito simples. O eixo horizontal representa um período de tempo (semanas, sprints etc) e o eixo vertical indica, de forma acumulada, o número de itens no processo (total de tarefas, total de histórias etc.). Cada área pintada no gráfico está relacionada a uma etapa no fluxo de trabalho (backlog, em progresso, finalizado etc) e as curvas são basicamente o número de itens acumulados em tais etapas.

* Para que o gráfico do CF faça sentido, é fundamental que ele possua apenas itens que farão parte de todo o processo de desenvolvimento. Isto significa dizer que, dado que o time assumiu o compromisso de desenvolver determinado item, este não poderá sair do processo, o que fará com que a linha superior nunca tenha o comportamento de queda.

<h3>Métricas que podem ser extraídas de um CFD</h3>

Você pode extrair de um CFD as seguintes métricas:

* WIP
* Lead Time Médio
* Throughput Médio

Uma forma de extrair informações úteis do CFD é através de perguntas, como por exemplo:

* O que está acontecendo com o nosso fluxo?
* Nossas métricas estão mostrando um bom ou mau caminho?
* Se estamos caminhando bem, como podemos manter?
* Se estamos com problemas, que tipo de mudança precisamos fazer para que o fluxo melhore?

<h3>Analisar a evolução do escopo e projetar prazos de entrega</h3>

O gráfico de burnup tem como objetivo:

* Aumentar a visibilidade do processo de desenvolvimento de software, garantindo que as pessoas interessadas no produto estejam alinhadas quanto ao progresso.
* Apresentar, visualmente, como o crescimento do escopo pode influenciar o resultado entregue no final de um prazo estipulado
Comunicar projeções de entrega com o objetivo de garantir alinhamento quanto às expectativas de entrega.

<h3>Burndown vs Burnup</h3>

* Os gráficos de burndown e burnup são tipos de visualizações que gestores e equipes utilizam para monitorar e comunicar o progresso de uma entrega.

* O gráfico de burndown mostra quanto trabalho está faltando ser concluído em um espaço de tempo (semana, quinzena, trimestre etc). Já o gráfico de burnup apresenta quanto de trabalho foi feito e o total de trabalho necessário para a entrega. Tais gráficos são usualmente utilizados por equipes que trabalham com frameworks como Scrum ou algum tipo de metodologia ágil.

* Conforme ilustrado, o gráfico de burndown é muito simples. Uma única linha é traçada e alcança o valor 0 quando a entrega estiver concluída.

* Enquanto o gráfico de burndown não exibe os avanços de entrega conquistados pela equipe, impedindo inclusive que pessoas que estão fora do dia a dia acompanhem o desempenho na medida em que são incluídas novas demandas, o gráfico de burnup permite que quem o visualiza avalie rapidamente se tudo está em conformidade com o planejado ou se é preciso mobilizar algum tipo de plano de ação. Além disso, o gráfico de burndown não apresenta variações no escopo do que está sendo trabalhado.

* Mudanças no escopo ocorrem quando um trabalho é adicionado ou removido. Vivenciamos mudanças quando um terceiro pede a inclusão de funcionalidades não previstas, ou quando é necessário remover algo do que havia sido planejado para que o prazo de entrega seja alcançado. O gráfico de burndown não mostra essa informação tão claramente quanto o gráfico de burnup, pois não possui, em uma mesma visualização, o tamanho do escopo (o que precisa ser feito) e o número de entregas realizadas até um determinado momento (o que já foi feito).

Utilize o burnup como forma de responder às seguintes perguntas:

* O escopo do projeto tem crescimento de forma saudável?
* Quando finalizamos o atual escopo de trabalho?

<h3>Utilizar o método de Monte Carlo para desenhar cenários de entrega</h3>

* A simulação de Monte Carlo é uma técnica estatística que tem como objetivo estimar a probabilidade de um certo resultado, por meio da geração de centenas ou milhares de cenários baseados em números aleatórios para as entradas em um sistema. Em outras palavras, a simulação pode ser definida como um método que se baseia em uma grande quantidade de amostragens aleatórias para se chegar em resultados próximos dos reais.

* O nome Monte Carlo surgiu como alusão a uma de suas principais características: a aleatoriedade na qual ocorre os jogos de cassino. Geralmente, o método é aplicado a problemas altamente incertos em que a computação direta é difícil, impraticável ou impossível. Ela provou ser uma ferramenta útil em diferentes situações, como na física nuclear, exploração de petróleo e gás, finanças, seguros etc.

<h3>Como a simulação de Monte Carlo pode ser útil no desenvolvimento de software?</h3>

* Antes que você passe a utilizar técnicas de projeção de cenários, sugiro que você faça uma reflexão sobre o quão saudável está o seu processo de desenvolvimento hoje. Se você tem um processo instável, os cenários futuros projetados pelas simulações não lhe dirão muita coisa.

Você pode identificar que o processo não está saudável quando:

* Existe uma alta variabilidade no lead time, isto é, itens levam muito tempo para serem entregues e outros são finalizados rápido demais.
* São observados gargalos ao longo do processo em decorrência do acúmulo de trabalho em etapas intermediárias. Alguns exemplos são: excesso de demandas aguardando validação; muito trabalho sendo estocado em uma etapa que exige o trabalho de um especialista (como teste ou deploy).
* Há um excesso de trabalho em andamento (WIP elevado). A taxa em que as demandas entram no processo é maior do que a taxa de saída (entrega).

Quando estabilizado o processo, você estará apto a trabalhar com a simulação de Monte Carlo, que possui a seguinte estrutura:

* Variáveis de entrada do sistema;
* Distribuição probabilística usada para cada variável;
* Variável de saída do sistema;

Ao trazer a estrutura apresentada para o dia a dia de uma equipe que monitora a informação de throughput, o modelo seria representado da seguinte maneira:

* Variáveis de entrada do sistema: throughput semanal.
* Distribuição probabilística: bootstrap com reposição da amostra de throughput já observada no projeto.
* Variável de saída do algoritmo: semana em que o escopo é finalizado, junto com a probabilidade de ocorrência.

<h3>O que é bootstrap?</h3>

* O termo bootstrap se refere, em geral, a uma técnica ou método de simulação, que objetiva a obtenção de intervalos de confiança para as estimativas dos parâmetros de interesse, por reamostragem do conjunto de dados original.

* A base da técnica é a obtenção de um “novo” conjunto de dados, por reamostragem do conjunto de dados original.

<h3>Dicas de como utilizar o gráfico de burnup e as projetos no seu dia a dia</h3>

* Não caia na tentação de usar dados do passado para prever o cenário de entrega de um novo projeto. O motivo é que novos contextos demandam novos dados. 

* Caso a equipe tenha ciência de que a área de negócios possui uma data de entrega fixada, passe a monitorar e negociar o que será o escopo de entrega e não quando ele será entregue. Costumo dizer para as equipes em que atuo que é mais positivo pensar em “o que será possível entregar até determinada data” do que agir com o pensamento de que  “não será possível entregar determinado escopo no prazo fixado” Prazo fixo exige um esforço de priorização, e por isso a utilização de técnicas como MoSCoW ou matriz de valor versus que lhe permitirão ser assertivo nas escolhas do que será parte do escopo de entrega.

* Ao iniciar um novo projeto ou produto, tenha ciência de que as primeiras semanas de trabalho serão de pouquíssimas entregas de valor, pois a equipe estará em processo de estruturação.

Caso você se depare com a necessidade de negociar o escopo, analise em primeiro lugar o que pode estar causando aumentos sucessivos no que será entregue. Crescimento no escopo geralmente é sinal de:

* Questões complexas que foram descobertas em determinado momento do projeto;
* Clientes e usuários que, ao interagirem com partes do produto que estão sendo construídas, começam a gerar novas demandas a partir de novas necessidades percebidas;

<h3>E agora o que fazer?</h3>

* Todas as discussões abordadas tiveram o intuito de reforçar a importância em se analisar e aplicar mudanças no processo, e não nas pessoas. É importante que você tenha um ambiente no qual as pessoas sejam estimuladas a criar, que tenham autonomia e que estejam engajadas no propósito do ambiente em que elas se encontram.

* Se você está interessado em medir quantas linhas de código um desenvolvedor criou na semana passada ou quantas funcionalidades um testador validou na última iteração, seu foco passa a ser a cobrança de performance, a comparação de desempenho e o microgerenciamento. No fundo, você cria uma cultura na qual há abuso de poder.

* Tenha em mente a todo momento que as métricas serão úteis para evoluir o processo, compreender o contexto, gerenciar os riscos, analisar as tendências, trabalhar com possibilidades e aumentar a visibilidade.

* Ao construir ou analisar uma métrica, se questione: estou avaliando de fato algo que ajudará a evoluir o meu processo, ou estou querendo analisar o desempenho de uma pessoa? Elimine qualquer tipo de controle que seja inútil no seu objetivo de trazer visibilidade e previsibilidade para o fluxo de desenvolvimento da sua equipe.

* Em hipótese alguma utilize as métricas como forma de comparar equipes. O motivo é simples: contexto.

* Não é porque o throughput da equipe A é de 10 funcionalidades por semana e o da equipe B é de 3, que a primeira entrega mais valor para o negócio do que a segunda. Evite cair na tentação de comparar equipes através das métricas. Já cansei de observar equipes que trabalham na mesma empresa e que possuem ritmos de entregas diferentes.

















 






